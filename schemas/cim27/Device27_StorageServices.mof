// ===================================================================
// Title:       Device Storage Services 2.7
// Filename:    Device27_StorageServices.mof
// Version:     2.7.1
// Release:     Final
// Date:        04/22/03
// ===================================================================
// Copyright 2002-2003 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.  
// DMTF is a not-for-profit association of industry members dedicated 
// to promoting enterprise and systems management and interoperability. 
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members, 
// provided that correct attribution is given. 
// As DMTF specifications may be revised from time to time, 
// the particular version and release date should always be noted.
//
// Implementation of certain elements of this standard or proposed 
// standard may be subject to third party patent rights, including 
// provisional patent rights (herein "patent rights"). DMTF makes 
// no representations to users of the standard as to the existence 
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or 
// claimants, nor for any incomplete or inaccurate identification or 
// disclosure of such rights, owners or claimants. DMTF shall have no 
// liability to any party, in any manner or circumstance, under any 
// legal theory whatsoever, for failure to recognize, disclose, or 
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product, 
// protocols or testing procedures. DMTF shall have no liability to 
// any party implementing such standard, whether such implementation 
// is foreseeable or not, nor to any patent owner or claimant, and shall 
// have no liability or responsibility for costs or losses incurred if 
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the 
// standard from any and all claims of infringement by a patent owner 
// for such implementations.
//
// For information about patents held by third-parties which have 
// notified the DMTF that, in their opinion, such patent may relate to 
// or impact implementations of DMTF standards, visit 
// http://www.dmtf.org/about/policies/disclosures.php.
// ===================================================================
// Description: The Device Model extends the management concepts that
//              are related to LogicalDevices. This file defines
//              a model for storage services.
//
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined 
//              by other working groups, are omitted.
// ==================================================================
// Change Log for v2.7.1
//       - Fix MaxValue declarations in StorageSettingWithHints - the
//         properties, AccessDirectionHint and AccessBandwidthWeight
//
// Change Log for v2.7 Final
// CR970 - Removal of the Experimental qualifier
//       - Remove StoragePool.GetSupportedSize and StoragePool.
//         GetSupportedSizeRange so they can remain experimental in 2.8
// CR978 - Clarify the use of settings and capabilities
//       - Change 'spindle' to 'package'
//       - Add ElementType in StoragePool methods
//       - Add ElementName to creation methods
//       - Fix ValueMap issues
//       - Generalize the "goal" parameter in CreateOrModifyElement
//       - Change units from megabytes to bytes.
// CR994 - Update description for InstanceID
//
// Change Log for v2.7
// CR775 - Add StorageSetting, StoragePool, StorageCapabilities,
//         StorageConfigurationService, StorageSettingsWithHints,
//         HostedStoragePool, and AllocatedStoragePool
// CR759 - Add ConfigurationReportingService
// CR777 - Add StorageSynchrononized 
//         Add StorageSetting.DeltaReservation, 
//         StorageCpabilities.DeltaReservationMin, 
//         StorageCpabilities.DeltaReservationMax, 
//         StorageCpabilities.DeltaReservationDefault, 
//         StorageConfigurationService.CreateReplica() and 
//         StorageConfigurationService.ModifySynchronization()
// CR895 - Correct the method return Values/ValueMaps for all the
//         methods in the ConfigurationReportingService.
// ================================================================== 

#pragma locale ("en_US")


// ==================================================================
// StorageSynchrononized
// ==================================================================
[Association, Version ("2.7.0"), Description (
    "Indicates that two Storage objects were replicated "
    "at the specified point in time. If the CopyType "
    "property is set to 'Sync' (=3), then synchronization "
    "of the Storage objects is preserved.") ]
class CIM_StorageSynchronized : CIM_Synchronized {

    [Override("SystemElement"), Description (
        "SystemElement represents the Storage that is "
        "the source of the replication.") ]
    CIM_LogicalElement REF SystemElement;

    [Override("SyncedElement"), Description (
        "SyncedElement represents the Storage that is "
        "the target of the replication.") ]
    CIM_LogicalElement REF SyncedElement;

    [Description(
        "CopyType describes the Replication Policy. "
        "Values are:  \n"
        "  Async: create and maintain an asynchronous "
        "copy of the source. \n"
        "  Sync: create and maintain a synchronized copy "
        "of the source. \n"
        "  UnSyncAssoc: create an unsynchronized copy and "
        "maintain an association to the source."),
        ValueMap {"2", "3", "4", "..", "32768..65535"},
        Values {"Async", "Sync", "UnSyncAssoc", 
            "DMTF Reserved", "Vendor Specific"} ]
    uint16 CopyType;
};


// ==================================================================
// StorageSetting                                                     
// ==================================================================
[Version ("2.7.0"), Description (
    "StorageSetting is roughly equivalent to a Service Level "
    "Agreement (SLA) It defines the characteristics, qualities "
    "of service and goals when used in a "
    "CreateOrModifyElementFromStoragePool or "
    "CreateOrModifyStoragePool "
    "method in the StorageConfigurationService. It specifies a "
    "series of properties with Maximum and Minimum values that define "
    "the (inclusive) bounds that the object should maintain. Note that "
    "the setting is associated to a StorageVolume, using ElementSetting.") ]
class CIM_StorageSetting : CIM_SettingData {
        
    [Write, Description (
        "Indicates the desired value for No Single Point of Failure. "
        "Possible values are false = single point of failure, and "
        "true = no single point of failure.") ]
    boolean NoSinglePointOfFailure;
 
    [Write, MinValue(1), Description (
        "DataRedundancyMax describes the maximum number of complete "
        "copies of data to be maintained. Examples would be RAID 5 "
        "where 1 copy is maintained and RAID 1 where 2 or more copies "
        "are maintained.  Possible values are 1 to n. The desired "
        "redundancy is specified using DataRedundancyGoal, while the "
        "minimum is defined by DataRedundancyMin."),
        ModelCorrespondence {"CIM_StorageSetting.DataRedundancyMin",
        "CIM_StorageSetting.DataRedundancyGoal"} ]
    uint16 DataRedundancyMax;
 
    [Write, MinValue(1), Description (
        "DataRedundancyMin describes the minimum number of complete "
        "copies of data to be maintained. Examples would be RAID 5 "
        "where 1 copy is maintained and RAID 1 where 2 or more copies "
        "are maintained.  Possible values are 1 to n. The desired "
        "redundancy is specified using DataRedundancyGoal, while the "
        "maximum is defined by DataRedundancyMax."),
        ModelCorrespondence {"CIM_StorageSetting.DataRedundancyMax",
        "CIM_StorageSetting.DataRedundancyGoal"} ]
    uint16 DataRedundancyMin;
 
    [Write, MinValue(1), Description (
        "DataRedundancyGoal describes the desired number of complete "
        "copies of data to be maintained. Examples would be RAID 5 "
        "where 1 copy is maintained and RAID 1 where 2 or more copies "
        "are maintained.  Possible values are 1 to n. The bounds (max "
        "and min) for redundancy are defined using the properties, "
        "DataRedundancyMax and DataRedundancyMin."), 
        ModelCorrespondence {"CIM_StorageSetting.DataRedundancyMax",
       "CIM_StorageSetting.DataRedundancyMin"} ]
    uint16 DataRedundancyGoal;
 
    [Write, Description (
        "PackageRedundancyMax describes the maximum number of redundant "
        "packages to be used. For example, in the storage domain, "
        "package redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. An example would be RAID5 with a spare disk which would "
        "have a PackageRedundancy of 2. Possible values are 0 to n. The "
        "desired redundancy is specified using PackageRedundancyGoal, "
        "while the minimum is defined by PackageRedundancyMin."),
        ModelCorrespondence {"CIM_StorageSetting.PackageRedundancyMin"
       "CIM_StorageSetting.PackageRedundancyGoal"} ]
     uint16 PackageRedundancyMax;
 
    [Write, Description (
        "PackageRedundancyMin describes the minimum number of redundant "
        "packages to be used. For example, in the storage domain, "
        "package redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. An example would be RAID5 with a spare disk which would "
        "have a PackageRedundancy of 2. Possible values are 0 to n. The "
        "desired redundancy is specified using PackageRedundancyGoal, "
        "while the maximum is defined by PackageRedundancyMax."),
        ModelCorrespondence {"CIM_StorageSetting.PackageRedundancyMax"
       "CIM_StorageSetting.PackageRedundancyGoal"} ]
     uint16 PackageRedundancyMin;
 
    [Write, Description (
        "PackageRedundancyGoal describes the desired number of redundant "
        "packages to be used. For example, in the storage domain, "
        "package redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. An example would be RAID5 with a spare disk which would "
        "have a PackageRedundancy of 2. Possible values are 0 to n. The "
        "bounds (max and min) for redundancy are defined using the properties, "
        "PackageRedundancyMax and PackageRedundancyMin."), 
        ModelCorrespondence {"CIM_StorageSetting.PackageRedundancyMax"
       "CIM_StorageSetting.PackageRedundancyMin"} ]
     uint16 PackageRedundancyGoal;
  
    [MinValue (1), MaxValue (100), Description (
        "DeltaReservationMax is a number between 1 (1%) and a 100 (100%) "
        "which specifies the maximum amount of space that should "
        "be reserved in a replica for caching changes. For a complete copy "
        "this would be 100%. The desired reservation is specified "
        "using DeltaReservationGoal, while the minimum is defined by "
        "DeltaReservationMin."), Units ("Percentage"),
        ModelCorrespondence {"CIM_StorageSetting.DeltaReservationMin"
       "CIM_StorageSetting.DeltaReservationGoal"} ]
    uint8 DeltaReservationMax;
 
    [MinValue (1), MaxValue (100), Description (
        "DeltaReservationMin is a number between 1 (1%) and a 100 (100%) "
        "which specifies the minimum amount of space that should "
        "be reserved in a replica for caching changes. For a complete copy "
        "this would be 100%. The desired reservation is specified "
        "using DeltaReservationGoal, while the maximum is defined by "
        "DeltaReservationMax."), Units ("Percentage"),
        ModelCorrespondence {"CIM_StorageSetting.DeltaReservationMax"
       "CIM_StorageSetting.DeltaReservationGoal"} ]
    uint8 DeltaReservationMin;
 
    [MinValue (1), MaxValue (100), Description (
        "DeltaReservationGoal is a number between 1 (1%) and a 100 (100%) "
        "which specifies the desired amount of space that should "
        "be reserved in a replica for caching changes. For a complete copy "
        "this would be 100%. The bounds (max and min) for the reservation "
        "are defined using the properties, DeltaReservationMax and "
        "DeltaReservationMin."), Units ("Percentage"), 
        ModelCorrespondence {"CIM_StorageSetting.DeltaReservationMin"
       "CIM_StorageSetting.DeltaReservationMax"} ]
    uint8 DeltaReservationGoal;
 
};
 
 
// ==================================================================
// StoragePool
// ==================================================================
[Version ("2.7.0"), Description (
    "A pool of Storage that is managed within the scope of a particular "
    "System. StoragePools may consist of component StoragePools or "
    "StorageExtents. StorageExtents that belong to the "
    "StoragePool have a Component relationship to the StoragePool. "
    "StorageExtents/StoragePools that are elements of a "
    "pool have their available space aggregated into the pool. "
    "StoragePools and StorageVolumes may be created from StoragePools. "
    "This is indicated by the AllocatedFromStoragePool association. "
    "StoragePool is scoped to a system by the HostedStoragePool "
    "association.") ] 
class CIM_StoragePool : CIM_LogicalElement {
    
    [Key, Description (
        "Within the scope of the instantiating Namespace, InstanceID "
        "opaquely and uniquely identifies an instance of this class. "
        "In order to ensure uniqueness within the NameSpace, the "
        "value of InstanceID SHOULD be constructed using the "
        "following 'preferred' algorithm: \n"
        "   <OrgID>:<LocalID> \n"
        "Where <OrgID> and <LocalID> are separated by a colon ':', "
        "and where <OrgID> MUST include a copyrighted, trademarked "
        "or otherwise unique name that is owned by the business entity "
        "creating/defining the InstanceID, or is a registered ID that is "
        "assigned to the business entity by a recognized global "
        "authority (This is similar to the <Schema Name>_<Class Name> "
        "structure of Schema class names.) In addition, to ensure "
        "uniqueness <OrgID> MUST NOT contain a colon (':'). When using "
        "this algorithm, the first colon to appear in "
        "InstanceID MUST appear between <OrgID> and <LocalID>.  \n"
        "   <LocalID> is chosen by the business entity and SHOULD not be "
        "re-used to identify different underlying (real-world) elements. "
        "If the above 'preferred' algorithm is not used, the defining "
        "entity MUST assure that the resultant InstanceID is not "
        "re-used across any InstanceIDs produced by this or other "
        "providers for this instance's NameSpace. \n"
        "For DMTF defined instances, the 'preferred' algorithm MUST be "
        "used with the <OrgID> set to 'CIM'.") ]        
    string InstanceID;
 
    [Required, MaxLen (256), Description (
        "A unique name in the context of the System that "
        "identifies this pool.") ]
    string PoolID;
 
    [Description (
         "Maximum available formatted space (in bytes) available "
         "via this pool."), 
         Units("Bytes") ]
    uint64 TotalAvailableSpace;
};  
 
 
// ==================================================================
// StorageCapabilities
// ==================================================================
[Version ("2.7.0"), Description (
    "A subclass of Capabilities that defines the " 
    "Capabilities of a StorageService or StoragePool. "
    "For example, an instance of StorageCapabilities could be"
    "associated with either a StorageConfigurationService or "
    "StoragePool by using ElementCapabilities.") ]
class CIM_StorageCapabilities : CIM_Capabilities {
 
    [Description (
        "Enumeration indicating the type of element to which this "
        "StorageCapabilities applies."),
        ValueMap{"0", "1", "2", "3", "4", "5", "6"},
        Values {"Unknown", "Reserved", "Any Type", "StorageVolume", 
            "StorageExtent", "StoragePool", 
            "StorageConfigurationService"} ]
    uint16 ElementType;
 
    [Description (
        "Indicates whether or not the associated element supports "
        "no single point of failure.  Values are: "
        "FALSE = does not support no single point of failure, "
        "and TRUE = supports no single point of failure."),
        ModelCorrespondence {
            "CIM_StorageCapabilities.NoSinglePointOfFailureDefault"} ]
    boolean NoSinglePointOfFailure;
 
    [Description (
        "Indicates the default value for the NoSinglePointOfFailure "
        "property."),
        ModelCorrespondence {
            "CIM_StorageCapabilities.NoSinglePointOfFailure"} ]
    boolean NoSinglePointOfFailureDefault;
 
    [MinValue (1), Description (
        "DataRedundancyMax describes the maximum number of complete "
        "copies of data that can be maintained. Examples would be "
        "RAID 5 (where 1 copy is maintained) and RAID 1 (where 2 or "
        "more copies are maintained).  Possible values are 1 to n. The "
        "default redundancy is specified using DataRedundancyDefault, "
        "while the minimum is defined by DataRedundancyMin."),
        ModelCorrespondence {"CIM_StorageCapabilities.DataRedundancyMin",
        "CIM_StorageCapabilities.DataRedundancyDefault"} ]
    uint16 DataRedundancyMax;
 
    [MinValue (1), Description (
        "DataRedundancyMin describes the minimum number of complete "
        "copies of data that can be maintained. Examples would be "
        "RAID 5 where 1 copy is maintained and RAID 1 where 2 or "
        "more copies are maintained).  Possible values are 1 to n. The "
        "default redundancy is specified using DataRedundancyDefault, "
        "while the maximum is defined by DataRedundancyMax."),
        ModelCorrespondence {"CIM_StorageCapabilities.DataRedundancyMax",
        "CIM_StorageCapabilities.DataRedundancyDefault"} ]
    uint16 DataRedundancyMin;
 
    [MinValue(1), Description (
        "DataRedundancyDefault describes the default number of "
        "complete copies of data that can be maintained. Examples "
        "would be RAID 5 where 1 copy is maintained and RAID 1 where "
        "2 or more copies are maintained.  Possible values are "
        "1 to n. The bounds for the redundancy (max and min) are "
        "defined by DataRedundancyMax and DataRedundancyMin."),
        ModelCorrespondence {"CIM_StorageCapabilities.DataRedundancyMax",
        "CIM_StorageCapabilities.DataRedundancyMin"} ]
    uint16 DataRedundancyDefault;
 
    [Description (
        "PackageRedundancyMax describes the maximum number of redundant "
        "packages that can be used. For example, in the storage domain, "
        "package redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. An example would be RAID5 with a spare disk which would "
        "have a PackageRedundancy of 2. Possible values are 0 to n."
        "The default redundancy is specified using PackageRedundancyDefault, "
        "while the maximum is defined by PackageRedundancyMax."),
        ModelCorrespondence {
        "CIM_StorageCapabilities.PackageRedundancyMin",
        "CIM_StorageCapabilities.PackageRedundancyDefault"} ]
    uint16 PackageRedundancyMax;
 
    [Description (
        "PackageRedundancyMin describes the minimum number of redundant "
        "packages that can be used. For example, in the storage domain, "
        "package redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. An example would be RAID5 with a spare disk which would "
        "have a PackageRedundancy of 2. Possible values are 0 to n."
        "The default redundancy is specified using PackageRedundancyDefault, "
        "while the minimum is defined by PackageRedundancyMin."),
        ModelCorrespondence {
        "CIM_StorageCapabilities.PackageRedundancyMax",
        "CIM_StorageCapabilities.PackageRedundancyDefault"} ]
    uint16 PackageRedundancyMin;
 
    [Description (
        "PackageRedundancyDefault describes the default number of redundant "
        "packages that will be used. For example, in the storage domain, "
        "package redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one " 
        "spare. An example would be RAID5 with a spare disk which would "
        "have a PackageRedundancy of 2. Possible values are 0 to n."
        "The bounds for redundancy are specified using the properties, "
        "PackageRedundancyMax and PackageRedundancyMin."),
        ModelCorrespondence {
        "CIM_StorageCapabilities.PackageRedundancyMin",
        "CIM_StorageCapabilities.PackageRedundancyMax"} ]
    uint16 PackageRedundancyDefault;
 
    [MinValue (1), MaxValue (100), Description (
        "DeltaReservatioMax is a number between 1 (1%) and a 100 (100%) "
        "that specifies the maximum amount of space reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the upper limit, while DeltaReservationMin sets the lower limit."),
        Units ("Percentage"), ModelCorrespondence {
            "CIM_StorageCapabilities.DeltaReservationMin",
            "CIM_StorageCapabilities.DeltaReservationDefault"} ]
    uint16 DeltaReservationMax;
 
    [MinValue (1), MaxValue (100), Description (
        "DeltaReservationMin is a number between 1 (1%) and a 100 (100%) "
        "that specifies the minimum amount of space that should be reserved "
        "in a replica for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the lower limit, while DeltaReservationMax sets the upper limit."), 
        Units ("Percentage"), ModelCorrespondence {
            "CIM_StorageCapabilities.DeltaReservationMax",
            "CIM_StorageCapabilities.DeltaReservationDefault"} ]
    uint16 DeltaReservationMin;
 
    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should be reserved by default in a "
        "replica for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the default value, while DeletaReservationMax and DeltReservationMin "
        "set the upper and lower bounds."),
        Units ("Percentage"), ModelCorrespondence {
            "CIM_StorageCapabilities.DeltaReservationMax",
            "CIM_StorageCapabilities.DeltaReservationMin"} ]
    uint16 DeltaReservationDefault;
};
 
// ==================================================================
// StorageConfigurationService 
// ==================================================================
[Version ("2.7.0"), Description (
    "This service allows the active management of a Storage "
    "Server. It allows jobs to be started for the creation, "
    "modification and deletion of storage objects (StoragePools "
    "and StorageVolumes).") ]
class CIM_StorageConfigurationService : CIM_Service {
 
    [Description (
        "Starts a job to create (or modify) a StoragePool.  The "
        "StoragePool will be (or must be) scoped to the same System "
        "as this Service. One of the parameters for this method is "
        "Size. As an input parameter, Size specifies the desired size of "
        "the pool. As an output parameter, it specifies the size achieved. "
        "Space is taken from either or both of the specified input "
        "StoragePools and StorageExtents (InPools and InExtents). "
        "The capability requirements that the Pool must support "
        "are defined using the Goal parameter. If the requested "
        "pool size cannot be created, no action will be taken, the "
        "Return Value will be 4097/0x1001, and the output value of "
        "Size will be set to the nearest possible size. If 0 is "
        "returned, then the task completed successfully and the "
        "use of ConcreteJob was not required. If the task will take "
        "some time to complete, a ConcreteJob will be created "
        "and its reference returned in the output parameter Job."),
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "..", 
            "4096", "4097", "4098..32767", "32768..65535"},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "In Use",
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Size Not Supported", "Method Reserved", 
            "Vendor Specific"} ]
    uint32 CreateOrModifyStoragePool ( 
        [IN, Description (
            "A end user relevant name for the pool being created. If "
            "NULL, then a system supplied default name can be used. The "
            "value will be stored in the 'ElementName' property for "
            "the created pool. If not NULL, this parameter "
            "will supply a new name when modifying an existing pool.") ]
        string ElementName,
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description (
            "Reference to an instance of StorageSetting that defines "
            "the desired capabilities of the StoragePool. If set to a "
            "null value, the default configuration from the source "
            "pool will be used. If not NULL, this parameter will supply a "
            "new Goal setting when modifying an existing pool." ) ]
        CIM_StorageSetting REF Goal,
        [IN, OUT, Description(
            "As an input parameter this specifies the desired pool size in bytes. "
            "As an output parameter this specifies the size "
            "achieved."), Units ("Bytes") ] 
        uint64 Size,
        [IN, Description (
           "Array of strings containing representations of "
           "references to CIM_StoragePool instances, that are used "
           "to create the Pool or modify the source pools.") ]
        string InPools[],
        [IN, Description (
           "Array of strings containing representations of "
           "references to CIM_StorageExtent instances, that are used "
           "to create the Pool or modify the source extents.") ]
        string InExtents[],
        [IN, OUT, Description (
            "As an input parameter: if null, creates a new StoragePool. "
            "If not null, modifies the referenced Pool. When returned, it is a "
            "reference to the resulting StoragePool.") ] 
        CIM_StoragePool REF Pool);
 
    [Description (
        "Start a job to create (or modify) a specified element (for "
        "example a StorageVolume or StorageExtent) from "
        "a StoragePool. One of the parameters for this method is "
        "Size. As an input parameter, Size specifies the desired size of the element. "
        "As an output parameter, it specifies the size achieved. "
        "Space is taken from the input StoragePool. The desired "
        "settings for the element are specified by the Goal parameter. "
        "If the requested size cannot be created, no action will be "
        "taken, and the Return Value will be 4097/0x1001. Also, "
        "the output value of Size is set to the nearest possible "
        "size. If 0 is returned, the function completed successfully "
        "and no ConcreteJob instance was required.  If 4096/0x1000 is "
        "returned, a ConcreteJob will be started to create the "
        "element. The Job's reference will be returned in the "
        "output parameter Job."), 
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "..", 
            "4096", "4097", "4098..32767", "32768..65535"},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "In Use",
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Size Not Supported", "Method Reserved",
            "Vendor Specific"} ]
    uint32 CreateOrModifyElementFromStoragePool(
        [IN, Description (
            "A end user relevant name for the element being created. If "
            "NULL, then a system supplied default name can be used. The "
            "value will be stored in the 'ElementName' property for "
            "the created element. If not NULL, this parameter "
            "will supply a new name when modifying an existing element.") ]
        string ElementName,
        [IN, Description (
            "Enumeration indicating the type of element being created "
            "or modified. If the input parameter TheElement is specified "
            "when the operation is a 'modify', this type value must "
            "match the type of that instance."),
            ValueMap{"0", "1", "2", "3", "..", "32768..65535"},
            Values {"Unknown", "Reserved", "StorageVolume", 
                "StorageExtent", "DMTF Reserved", "Vendor Specific"} ]
        uint16 ElementType,
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description(
            "The requirements for the element to maintain. If set to "
            "a null value, the default configuration from the source "
            "pool will be used. This parameter should be a reference to "
            "a Setting or Profile appropriate to the element being "
            "created. If not NULL, this parameter "
            "will supply a new Goal when modifying an existing element.") ]
        CIM_ManagedElement REF Goal,
        [IN, OUT, Description (
            "As an input parameter Size specifies the desired size. "
            "If not NULL, this parameter "
            "will supply a new size when modifying an existing element."
            "As an output parameter Size specifies the size "
            "achieved."), Units ("Bytes") ] 
        uint64 Size,
        [IN, Description(
            "The Pool from which to create the element. This parameter "
            "must be set to null if the input parameter TheElement is "
            "specified (in the case of a 'modify' operation).") ] 
        CIM_StoragePool REF InPool,
        [IN, OUT, Description (
            "As an input parameter: if null, creates a new element. If "
            "not null, then the method modifies the specified element. "
            "As an output parameter, it is a reference to the "
            "resulting element.") ] 
        CIM_LogicalElement REF TheElement);
 
    [Description (
        "Start a job to delete a StoragePool. The freed space is "
        "returned source StoragePools (indicated by AllocatedFromStoragePool) "
        "or back to underlying storage extents.  If 0 is returned, the "
        "function completed successfully, and no ConcreteJob was required. "
        "If 4096/0x1000 is returned, a ConcreteJob will be started "
        "to delete the StoragePool. A reference to the Job is returned "
        "in the Job parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "..", "4096",
            "4097..32767", "32768..65535"},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "In Use",
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 DeleteStoragePool (
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description(
            "Reference to the pool to delete.") ] 
        CIM_StoragePool REF Pool);
 
    [Description (
        "Start a job to delete an element previously created from a "
        "StoragePool. The freed space is returned to the source "
        "StoragePool. If 0 is returned, the function completed "
        "successfully and no ConcreteJob was required. If 4096/0x1000 "
        "is returned, a ConcreteJob will be started to delete the "
        "element. A reference to the Job is returned in the Job "
        "parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "..", "4096",
            "4097..32767", "32768..65535"},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "In Use",
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 ReturnToStoragePool(
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description(
            "Reference to the element to return to the StoragePool.") ] 
        CIM_LogicalElement REF TheElement);
 
    [Description (
        "Start a job to create a new storage object which "
        "is a replica of the specified source storage object. "
        " (SourceElement). Note that using "
        "the input paramter, CopyType, this function can be used to "
        "instantiate the replica, and to create an ongoing "
        "association between the source and replica. If 0 is "
        "returned, the function completed successfully and no "
        "ConcreteJob instance is created. If 4096/0x1000 is returned, "
        "a ConcreteJob is started, a reference to which is "
        "returned in the Job output parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "..", "4096",
            "4097..32767", "32768..65535"},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "In Use",
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 CreateReplica(
        [IN, Description (
            "A end user relevant name for the element being created. If "
            "NULL, then a system supplied default name can be used. The "
            "value will be stored in the 'ElementName' property for "
            "the created element.") ]
        string ElementName,
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Required, Description(
            "The source storage object which may be a StorageVolume or "
            "storage object.") ]
        CIM_LogicalElement REF SourceElement,
        [OUT, IN(false), Description(
            "Reference to the created target storage element "
            "(i.e., the replica).") ]
        CIM_LogicalElement REF TargetElement,
        [IN, Description(
            "The definition for the StorageSetting to be maintained "
            "by the target storage object (the replica).") ]
        CIM_StorageSetting REF TargetSettingGoal,
        [IN, Description(
            "The underlying storage for the target element (the "
            "replica) will be drawn from TargetPool if specified, "
            "otherwise the allocation is implementation specific.") ] 
        CIM_StoragePool REF TargetPool,
        [IN, Description(
            "CopyType describes the type of copy that will be made. "
            "Values are: \n "
            "  Async: Create and maintain an asynchronous "
            "copy of the source. \n "
            "  Sync: Create and maintain a synchronized copy "
            "of the source. \n" 
            "  UnSyncAssoc: Create an unsynchronized copy and "
            "maintain an association to the source. \n "
            "  UnSyncUnAssoc: Create unassociated copy of the "
            "source element."),
            ValueMap {"2", "3", "4", "5", "..", "32768..65535"},
            Values {"Async", "Sync", "UnSyncAssoc", "UnSyncUnAssoc",
                "DMTF Reserved", "Vendor Specific"} ]
        uint16 CopyType);
 
    [Description (
        "Starts a job to modify the synchronization association "
        "between two storage objects. If 0 is returned, the "
        "function completed successfully and no ConcreteJob instance "
        "was created. If 4096/0x1000 is returned, a ConcreteJob "
        "was started. A reference to this Job is returned in "
        "the Job output parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "..", "4096",
            "4097..32767", "32768..65535"},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "In Use","DMTF Reserved", 
            "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 ModifySynchronization(
        [IN, Description(
            "Operation describes the type of modification "
            "to be made to the replica. Values are: \n "
             "  Detach: 'Forget' the synchronization between "
             "two storage objects. Start to treat the objects as "
             "independent. \n "
             "  Fracture: Suspend the synchronization between "
             "two storage objects. The association and "
             "(typically) changes are remembered to allow a fast "
             "resynchronization. This may be used during "
             "a backup cycle to allow one of the objects to be "
             "copied while the other remains in production. \n"
             "  Resync Replica: Re-establish the synchronization of "
             "a replica. This will negate the action of a previous "
             "Fracture operation. \n"
             "  Restore from Replica: Renew the contents of "
             "the original storage object from a replica."),
             ValueMap {"0","1","2", "3", "4", "5", "..", 
                 "32768..65535"},
             Values {" DMTF Reserved", "DMTF Reserved", "Detach", 
                 "Fracture", "Resync Replica", "Restore from Replica"
                 "DMTF Reserved", "Vendor Specific"} ]
        uint16 Operation,
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description(
            "The referenced to the StorageSynchronized association "
            "describing the storage source/replica relationship.") ]
        CIM_StorageSynchronized REF Synchronization);
};
 
 
// ====================================================================
// StorageSettingWithHints
// ====================================================================
[Version("2.7.1"), Description (
    "This subclass of StorageSetting allows a client to specify "
    "'hint's for optimization of the volume performance. The effect "
    "of these hints is implementation dependent.") ]
class CIM_StorageSettingWithHints: CIM_StorageSetting {
    
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the importance "
        "placed on data availability. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 DataAvailabilityHint;
        
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the randomness "
        "of accesses. Values are 0=Entirely Sequential to "
        "10=Entirely Random.") ]
    uint16 AccessRandomnessHint;
 
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the direction "
        "of accesses. Values are 0=Entirely Read to "
        "10=Entirely Write.") ]
    uint16 AccessDirectionHint;
 
    [Description (
        "This hint is an indication from a client of the optimal "
        "access sizes (in bytes).  Since this  property is an array, "
        "several sizes can be specified. "),
        Units ("Bytes") ]
    uint16 AccessSizeHint[];
 
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client how important "
        "access latency is. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 AccessLatencyHint;
 
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of bandwidth "
        "prioritization. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 AccessBandwidthWeight;
 
    [MinValue (0), MaxValue (10),Description (
        "This hint is an indication of the importance the client "
        "places on the cost of storage. Values are 0=Don't Care to "
        "10=Very Important. A StorageVolume provider might choose "
        "to place data on low cost or high cost drives based on "
        "this parameter.") ]
    uint16 StorageCostHint;
 
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication of the importance placed on "
        "storage space efficiency by the client. Values are 0=Don't Care "
        "to 10=Very Important. A StorageVolume provider might choose "
        "different RAID levels based on this hint.") ]
    uint16 StorageEfficiencyHint;
};
 
 
// ===================================================================
// AllocatedFromStoragePool
// ===================================================================
[Association, Version ("2.7.0"), Description (
    "AllocatedFromStoragePool is an association describing how "
    "LogicalElements are allocated from underlying StoragePools. "
    "These elements typically would be subclasses of StorageExtents "
    "or StoragePools.") ] 
class CIM_AllocatedFromStoragePool : CIM_Dependency {
    
    [Override ("Antecedent"), 
        Description ("The StoragePool.") ]
    CIM_StoragePool REF Antecedent;
 
    [Override ("Dependent"),
        Description ("The subsidiary element.") ]
    CIM_LogicalElement REF Dependent;
 
    [Description (
        "Space consumed from this Pool, in bytes."), Units("Bytes") ]
    uint64 SpaceConsumed;
};
 

// ==================================================================
// HostedStoragePool
// ==================================================================
[Association, Aggregation, Composition, 
    Version ("2.7.0"), Description (
        "SystemStoragePool is a specialization of SystemComponent "
        "association that establishes that the StoragePool is "
        "defined in the context of the System.") ]
class CIM_HostedStoragePool : CIM_SystemComponent {
        
    [Override ("GroupComponent"), Aggregate, Max (1), Min (1), 
        Description ("The parent system in the Association.") ] 
    CIM_System REF GroupComponent;
 
    [Override ("PartComponent"), Description (
        "The StoragePool that is a component of a System.") ] 
    CIM_StoragePool REF PartComponent;
};


// ===================================================================
// ConfigurationReportingService
// ===================================================================
[Description (
    "Service to provide reports on current configuration and "
    "potential for growth. The service may be used in several "
    "circumstances: \n"
    "- To report growth potential (how many can I have) \n"
    "- To report information on objects not directly modeled for "
    "performance or other reasons. \n "
    "It can also report counts of 'things' or counts of 'units'. "
    "For example, the number of disk drives could be reported or the "
    "capacity that they would provide.") ]
class CIM_ConfigurationReportingService : CIM_Service {

    [Description(
        "Returns a list of classes that the given Managed"
        "Element supports or has installed."), 
        ValueMap {"0", "1", "2", "3", "4", "..", "32768..65535"},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 GetClassTypes(
        [IN, ValueMap {"2", "3"}, 
            Values {"Supports", "Installed"},
            Description (
                "The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description(
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.") ]
        boolean Recursive,
        [IN, Description(
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [OUT, IN (false), Description(
            "Array containing the class names (typically the leaf "
            "classes) that the given ManagedElement can support or "
            "has installed.") ]
        string ClassTypes[]);

    [Description(
        "Returns a list of UnitTypes that are installed for "
        "a given ClassType on a given ManagedElement."),
        ValueMap {"0", "1", "2", "3", "4", "..", "32768..65535"},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 GetUnitTypes(
        [IN, ValueMap {"2", "3"}, 
            Values {"Supported", "Installed"},
            Description ("The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description(
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.") ]
        boolean Recursive,
        [IN, Description(
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [IN, Description(
            "The ClassType for the query. This should be a entry "
            "returned in the GetClassTypes.ClassTypes property.") ]
        string ClassType,
        [OUT, IN (false), Description(
            "A list of supported UnitTypes."),
            ValueMap{"2", "3", "4", "5", "6", "7", "8", "9", 
                "10", "..", "32768..65535"},
            Values {"None", "Front Side", "Back Side", "Contained",
                "Connected", "I/O", "Memory", "StorageMediaLocation",
                "Megabytes", "DMTF Reserved", "Vendor Specific"},
            ModelCorrespondence {
                "CIM_ConfigurationReportingService."
                "ReportCapacity(UnitType)"} ]
        uint16 UnitTypes[]);

    [Description(
        "Returns the maximum number supported or the "
        "number of currently installed units for the given UnitType, "
        "for a given ClassType on a given ManagedElement."),
        ValueMap {"0", "1", "2", "3", "4", "..", 
            "32768..65535"},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 ReportCapacity(
        [IN, ValueMap {"2", "3"}, 
            Values {"Supported", "Installed"},
            Description ("The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description(
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.") ]
        boolean Recursive,
        [IN, Description(
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [IN, Description(
            "The ClassType for the query. This should be a entry "
            "returned in the GetClassTypes.ClassTypes property.") ]
        string ClassType,
        [IN, Description(
            "The UnitType for the query."),
            ValueMap{"2", "3", "4", "5", "6", "7", "8", "9",
                "10", "..", "32768..65535"},
            Values {"None", "Front Side", "Back Side", "Contained",
                "Connected", "I/O", "Memory", "StorageMediaLocation",
                "Megabytes", "DMTF Reserved", "Vendor Specific"},
            ModelCorrespondence {
                "CIM_ConfigurationReportingService."
                "GetUnitTypes(UnitTypes)"} ]
        uint16 UnitType,
        [OUT, IN (false), Description (
            "The maximum number of supported or the number of "
            "currently installed units.") ]
        uint64 NumberOfUnits);
};


// ===================================================================
// end of file
// ===================================================================
