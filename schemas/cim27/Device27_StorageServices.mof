// ===================================================================
// Title:       Storage Services 2.7
// Filename:    Device27_StorageServices.mof
// Version:     2.7.0
// Release:     Preliminary 
// Date:        06/09/02
// ===================================================================
// Copyright 2002 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.  
// DMTF is a not-for-profit association of industry members dedicated 
// to promoting enterprise and systems management and interoperability. 
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members, 
// provided that correct attribution is given. 
// As DMTF specifications may be revised from time to time, 
// the particular version and release date should always be noted.
//
// Implementation of certain elements of this standard or proposed 
// standard may be subject to third party patent rights, including 
// provisional patent rights (herein "patent rights"). DMTF makes 
// no representations to users of the standard as to the existence 
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or 
// claimants, nor for any incomplete or inaccurate identification or 
// disclosure of such rights, owners or claimants. DMTF shall have no 
// liability to any party, in any manner or circumstance, under any 
// legal theory whatsoever, for failure to recognize, disclose, or 
// identify any such third party patent rights, or for such party’s
// reliance on the standard or incorporation thereof in its product, 
// protocols or testing procedures. DMTF shall have no liability to 
// any party implementing such standard, whether such implementation 
// is foreseeable or not, nor to any patent owner or claimant, and shall 
// have no liability or responsibility for costs or losses incurred if 
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the 
// standard from any and all claims of infringement by a patent owner 
// for such implementations.
//
// For information about patents held by third-parties which have 
// notified the DMTF that, in their opinion, such patent may relate to 
// or impact implementations of DMTF standards, visit 
// http://www.dmtf.org/about/policies/disclosures.php.
// ===================================================================
// Description: The Device Model extends the management concepts that
//              are related to LogicalDevices.
//              This Device file defines the concepts for modeling
//              storage services.
//
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined 
//              by other working groups, are omitted.
// ==================================================================
// Prerequisite:  Core27_Qualifiers
//                Core27_CoreElements (ME & MSE)
// ==================================================================
// Change Log for v2.7
//
// CR775 - Add StorageSetting, StoragePool, StorageCapabilities,
//         StorageConfigurationService, StorageSettingsWithHints,
//         HostedStoragePool, and AllocatedStoragePool.
// CR759 - Add ConfigurationReportingService.GetClassTypes()
//         Add ConfigurationReportingService.GetUnitTypes()
//         Add ConfigurationReportingService.ReportCapacity()
// CR777 - Add StorageSynchrononized 
//         Add StorageSetting.DeltaReservation
//         Add StorageCpabilities.DeltaReservationMin     
//         Add StorageCpabilities.DeltaReservationMax     
//         Add StorageCpabilities.DeltaReservationDefault 
//         Add StorageConfigurationService.CreateReplica()
//         Add StorageConfigurationService.ModifySynchronization()
//
// ================================================================== 

#pragma locale ("en_US")


// ==================================================================
// StorageSynchrononized
// ==================================================================
[Association, Experimental, Version ("2.7.0"), Description (
    "Indicates that two Storage objects were replicated "
    "at the specified point in time. If the CopyType "
    "property is set to 'Sync' (=3), then synchronization "
    "of the Storage objects is preserved.") ]
class CIM_StorageSynchronized: CIM_Synchronized {

    [Override("SystemElement"), Key, Description (
        "SystemElement represents the Storage that is"
        "the source of the replication.") ]
    CIM_LogicalElement ref SystemElement;

    [Override("SyncedElement"), Key, Description (
        "SyncedElement represents the Storage that is"
        "the target of the replication. ") ]
    CIM_LogicalElement ref SyncedElement;

    [Description(
        "CopyType describes the Replication Policy."
        "Values are:  \n"
        "  Async: create and maintain an asynchronous \n"
        "        copy of the source. \n"
        "  Sync: create and maintain a synchronized copy \n"
        "        of the source. \n"
        "  UnSyncAssoc: create an unsynchronized copy and \n"
        "        maintain an association to the source."),
        ValueMap {"2", "3", "4", "..", "0x8000.."},
        Values {"Async", "Sync", "UnSyncAssoc", 
            "DMTF Reserved", "Vendor Specific"} ]
    uint16 CopyType;
};


// ==================================================================
// StorageSetting                                                     
// ==================================================================
[Experimental, Version ("2.7.0"), Description (
    "StorageSetting is roughly equivalent to a Service Level "
    "Agreement (SLA) when associated by ElementSetting "
    "to a StorageVolume.  StorageSetting is a Service "
    "Level Objective (SLO) when used in a StartCreateStorageVolume "
    "method. It defines a series of properties with Maximum and "
    "Minimum values that the object should stay between.") ]
class CIM_StorageSetting: CIM_SettingData {
        
    [Write, Description (
        "Indicates the desired value for No Single Point of Failure. "
        "Possible values are false = single point of failure, and "
        "true = no single point of failure.")]
    boolean NoSinglePointOfFailure;

    [Write, MinValue(1), Description (
        "DataRedundancyMax describes the maximum number of complete "
        "copies of data to be maintained. Examples would be RAID 5 "
        "where 1 copy is maintained and RAID 1 where 2 or more copies "
        "are maintained.  Possible values are 1 to n.")]
    uint16 DataRedundancyMax;

    [Write, MinValue(1),Description (
        "DataRedundancyMin describes the minimum number of complete "
        "copies of data to be maintained. Examples would be RAID 5 "
        "where 1 copy is maintained and RAID 1 where 2 or more copies "
        "are maintained. Possible values are 1 to n.")]
    uint16 DataRedundancyMin;

    [Write, Description (
        "SpindleRedundancyMax describes the maximum number of spindles "
        "to be used. Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n.") ]
    uint16 SpindleRedundancyMax;

    [Write, Description (
        "SpindleRedundancyMin describes the minimum number of spindles "
        "to be used. Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n.") ]
    uint16 SpindleRedundancyMin;
    
    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations.") ]
    uint16 DeltaReservation;
};


// ==================================================================
// StoragePool
// ==================================================================
[Experimental, Version ("2.7.0"), Description (
    "A pool of Storage that is managed by a particular "
    "System. StoragePools may consist of component StoragePools or "
    "StorageExtents. StorageExtents/StoragePools that belong to the "
    "StoragePool have a Component relationship to the StoragePool. "
    "StorageExtents/StoragePools that are components of a "
    "pool have their available space aggregated into the pool. "
    "StoragePools and StorageVolumes may be created from StoragePools. "
    "This is indicated by the AllocatedFromStoragePool association "
    "StoragePool is scoped to a system by the SystemStoragePool "
    "association.") ] 
class CIM_StoragePool : CIM_LogicalElement {
    
    [Key, Description (
        "InstanceID opaquely identifies a unique instance of "
        "StoragePool.  The InstanceID must be unique within a "
        "namespace. In order to ensure uniqueness, the value of "
        "InstanceID SHOULD be constructed in the following manner: \n"
        "<Vendor ID><ID> \n"
        "   <Vendor ID> MUST include a copyrighted, trademarked "
        "or otherwise unique name that is owned by the business "
        "entity or a registered ID that is assigned to the business "
        "entity that is defining the InstanceID. (This is similar to "
        "the <Schema Name>_<Class Name> structure of Schema class "
        "names.) The purpose of <Vendor ID> is to ensure that <ID> is "
        "truly unique across multiple vendor implementations.   "
        "If such a name is not used, the defining entity MUST assure "
        "that the <ID> portion of the Instance ID is unique when "
        "compared with other instance providers. For DMTF defined "
        "instances, the <Vendor ID> is 'CIM'. \n"
        "   <ID> MUST include a vendor specified unique "
        "identifier.") ]        
    string InstanceID;

    [Required, MaxLen (256), Description (
        "A unique name in the context of the System that "
        "identifies this pool.") ]
    string PoolID;

    [Description (
        "For pools that support discrete sizes for volume or "
        "pool creation, this method can be used to retrieve a "
        "list of supported sizes. Note that different pool "
        "implementations may support either or both the "
        "GetSupportedSizes and GetSupportedSizeRanges at different "
        "times depending on Pool configuration. Also note that the "
        "advertised size may change after the call due to requests "
        "from other clients. If the pool currently only supports a "
        "range of sizes, then the return value will be set to 1."),
        ValueMap {"0", "1", "2"},
        Values {"Method completed OK", "Method not supported",
            "Use GetSupportedSizeRange instead"}]
    uint32 GetSupportedSizes (
        [IN, Description (
            "Specifies the size requirements.")]
        CIM_StorageSetting ref Goal,
        [OUT, IN(false), Description (
            "List of support sizes for a Volume/Pool creation or "
            "modification."),
            Units ("MegaBytes")]
        uint64  Sizes[] );

    [Description (
        "For pools that that support a range of sizes for volume or "
        "pool creation, this method can be used to retrieve the "
        "supported range. Note that different pool implementations "
        "may support either or both the GetSupportedSizes and "
        "GetSupportedSizeRanges at different times depending on Pool "
        "configuration. Also note that the advertised size may change "
        "after the call due to requests from other clients. If the "
        "pool currently only supports discrete sizes, then the return "
        "value will be set to 1."),
        ValueMap {"0", "1", "2"},
        Values {"Method completed OK", "Method not supported",
            "Use GetSupportedSizes instead"}]
    uint32 GetSupportedSizeRange (
        [IN, Description (
            "Specifies the size requirements.")]
        CIM_StorageSetting ref Goal,
        [OUT, IN(false), Description (
            "The minimum size for a volume/pool."),
            Units ("MegaBytes")]
        uint64  MinimumVolumeSize,
        [OUT, IN(false), Description (
            "The maximum size for a volume/pool."),
             Units ("MegaBytes")]
        uint64  MaximumVolumeSize,
        [OUT, IN(false), Description (
            "A volume/pool size must be a multiple of this value."),
            Units ("MegaBytes")]
        uint64  VolumeSizeDivisor);

    [Description (
         "Raw available space in the pool."), Units("MegaBytes")]
    uint64 TotalAvailableSpace;
 
};  

 
// ==================================================================
// StorageCapabilities
// ==================================================================
[Experimental, Version ("2.7.0"), Description (
    "This Capabilities subclass defines the " 
    "Capabilities of a Storage Service or Storage Pool. "
    "For example, an instance of StorageCapabilities could be"
    "associated with either a StorageConfigurationService or "
    "StoragePool by using ElementCapabilities.") ]
class CIM_StorageCapabilities: CIM_Capabilities {

    [Description (
        "Enumeration indicating the type of instance this "
        "Storage Capabilities applies to."),
        ValueMap{"0", "1", "2", "3", "4", "5", "6"},
        Values {"Unknown", "Reserved", "Any Type", "StorageVolume", 
            "StorageExtent", "StoragePool", 
            "StorageConfigurationService"} ]
    uint16 InstanceType;


    [Description (
        "Indicates whether or not the associated instance supports "
        "no single point of failure.  Possible values are "
        "false = does not support no single point of failure, "
        "true = supports no single point of failure. ")]
    boolean NoSinglePointOfFailure;

    [Description (
        "Indicates the default value for the NoSinglePointOfFailure "
        "property."),
        ModelCorrespondence {
            "CIM_StorageCapabilities.NoSinglePointOfFailure"} ]
    boolean NoSinglePointOfFailureDefault;

    [MinValue (1), Description (
        "DataRedundancyMax describes the maximum number of complete "
        "copies of data that can be maintained. Examples would be "
        "RAID 5 where 1 copy is maintained and RAID 1 where 2 or "
        "more copies are maintained.  Possible values are 1 to n.") ]
    uint16 DataRedundancyMax;

    [MinValue (1), Description (
        "DataRedundancyMin describes the minimum number of complete "
        "copies of data that can be maintained. Examples would be "
        "RAID 5 where 1 copy is maintained and RAID 1 where 2 or "
        "more copies are maintained.  Possible values are 1 to n.") ]
    uint16 DataRedundancyMin;

    [MinValue(1), Description (
        "DataRedundancyDefault describes the default number of "
        "complete copies of data that can be maintained. Examples "
        "would be RAID 5 where 1 copy is maintained and RAID 1 where "
        "2 or more copies are maintained.  Possible values are "
        "1 to n.") ]
    uint16 DataRedundancyDefault;

    [Description (
        "SpindleRedundancyMax describes the maximum number of spindles "
        "that can be used.  Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n.")]
    uint16 SpindleRedundancyMax;

    [Description (
        "SpindleRedundancyMin describes the minimum number of spindles "
        "that can be used.  Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n.")]
    uint16 SpindleRedundancyMin;

    [Description (
        "SpindleRedundancyDefault describes the default number of "
        "spindles that can be used.  Spindle redundancy describes "
        "how many disk spindles can fail without data loss including, "
        "at most, one spare. Examples would be RAID5 with a Spindle "
        "Redundancy of 1, RAID6 with 2, RAID 6 with 2 spares would be "
        "3. Possible values are 0 to n.")]
    uint16 SpindleRedundancyDefault;

    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the upper limit.") ]
    uint16 DeltaReservationMax;

    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the lower limit") ]
    uint16 DeltaReservationMin;

    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the default value") ]
    uint16 DeltaReservationDefault;
};


// ==================================================================
// StorageConfigurationService 
// ==================================================================
[Experimental, Version ("2.7.0"), Description (
    "This service allows the active management of a Storage "
    "Server. It allows jobs to be started for the creation, "
    "modification and deletion of Storage Objects (Storage Pools "
    "and Storage Volumes).")]
class CIM_StorageConfigurationService : CIM_Service {

    [Description (
        "Starts a job to create (or modify) a StoragePool.  The "
        "StoragePool will be (or must be) scoped to the same System as "
        "this service. One of the parameters for this method is Size. "
        "As an input parameter Size specifies the desired size. "
        "As an output parameter Size specifies the size achieved.  "
        "Space is taken from either or both of the specified "
        "StoragePools and StorageExtents.  The capability requirements "
        "that the Pool must support are passed in by the "
        "Goal parameter. If the requested size cannot be created, "
        "no action will be taken, the Return Value will be 0x1002 "
        "and the output value, size will be set to the nearest "
        "possible size. If 0 is returned, then the task completed "
        "successfully and the use of ConcreteJob was not required."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", 
            "0x1000", "0x1001", "0x1002..0x7777", "0x8000.."},
        Values {"Job completed with no error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", "Method parameters checked - job started",
            "Size not supported", "Method Reserved", 
            "Vendor Specific"} ]
    uint32 CreateOrModifyStoragePool ( 
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob ref Job,
        [IN, Description (
            "Reference to an instance of StorageSetting that defines "
            "the desired capabilities of the StoragePool. If set to a "
            "null value, the default configuration from the source "
            "pool will be used.")]
        CIM_StorageSetting ref Goal,
        [IN, OUT, Description(
            "As an input parameter this specifies the desired size. "
            "As an output parameter this specifies the size "
            "achieved.") ] 
        uint64 Size,
        [IN, Description (
           "Array of strings containing representations "
           "of references to CIM_StoragePool instances.") ]
        string InPool[],
        [IN, Description (
           "Array of strings containing representations"
           "of references to CIM_StorageExtent instances.") ]
        string Extent[],
        [IN, OUT, Description (
            "As an input parameter: if null create a new StoragePool. "
            "If not null, modify Pool. Returned parameter is a "
            "reference to the resulting StoragePool.") ] 
        CIM_StoragePool ref Pool);

    [Description (
        "Start a job to create (or modify) a specified element (for "
        "example a StorageVolume, StorageExtent, or StoragePool) from "
        "a StoragePool.  One of the parameters for this method is Size."
        "  As an input parameter Size specifies the desired size. "
        "As an output parameter Size specifies the size achieved.  "
        "Space is taken from the input StoragePool. The desired "
        "settings for the element are specified by the Goal parameter. "
        "If the requested size cannot be created, "
        "no action will be taken, and the Return Value will be 0x1001 "
        "(the output value, size, will be set to the nearest possible "
        "size). If 0 is returned, the function completed successfully "
        "and no ConcreteJob instance was required.  If 0x1000 a "
        "ConcreteJob will be started to create the element."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", 
            "0x1000", "0x1001", "0x1002..0x7777", "0x8000.."},
        Values {"Job completed with no error", "Not Supported", 
            "Unknown", "Timeout", "Failed","Invalid Parameter", 
            "DMTF Reserved", "Method parameters checked - job started",
            "Size not supported", "Method Reserved","Vendor Specific"} ]
    uint32 CreateOrModifyElementFromStoragePool(
        [IN, Description (
            "Enumeration indicating the type of element being created "
            "or modified. If the input parameter Element is specified "
            "(for the case of modify), this type value must match the "
            "type of that instance."),
            ValueMap{"0", "1", "2", "3", "..", "0x8000.."},
            Values {"Unknown", "Reserved", "StorageVolume", 
                "StorageExtent", "DMTF Reserved", "Vendor Specific"} ]
        uint16 ElementType,
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob ref Job,
        [IN, Description(
            "The requirements for the element to maintain. If set to "
            "a null value, the default configuration from the source "
            "pool will be used.") ]
        CIM_StorageSetting ref Goal,
        [IN, OUT, Description (
            "As an input parameter Size specifies the desired size. "
            "As an output parameter Size specifies the size "
            "achieved.") ] 
        uint64 Size,
        [IN, Description(
            "The Pool to create the element from. This parameter "
            "must be set to null if the input parameter Element is "
            "specified (in the case for modify).") ] 
        CIM_StoragePool ref InPool,
        [IN, OUT, Description (
            "As an input parameter: if null create a new element. If "
            "not null, then modify the specified element. Returned "
            "parameter is a reference to the resulting element.") ] 
        CIM_LogicalElement ref TheElement);

    [Description (
        "Start a job to delete a StoragePool. The freed space is "
        "returned to the source StoragePool.  If 0 is returned, the "
        "function completed successfully, then no ConcreteJob was "
        "required. If 0x1000 a ConcreteJob will be started to "
        "delete the StoragePool"),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job completed with no error", "Not Supported", 
            "Unknown", "Timeout", "Failed","Invalid Parameter", 
            "DMTF Reserved", "Method parameters checked - job started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 DeleteStoragePool (
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob ref Job,
        [IN, Description(
            "Reference to the pool to delete.")] 
        CIM_StoragePool ref Pool);

    [Description (
        "Start a job to delete an element previously created from a "
        "StoragePool. The freed space is returned to the source "
        "StoragePool. If 0 is returned, the function completed "
        "successfully and no ConcreteJob was required. If 0x1000 a "
        "ConcreteJob will be started to delete the element."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job completed with no error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", "Method parameters checked - job started",
            "Method Reserved", "Vendor Specific"}]
    uint32 ReturnToStoragePool(
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).")]
        CIM_ConcreteJob ref Job,
        [IN, Description(
            "Reference to the element to return to the StoragePool.")] 
        CIM_LogicalElement ref TheElement);

    [Description (
        "Start a job to create a new Storage Object which "
        "is a Replica of the Source storage object. Note that based "
        "on, CopyType this function can be used to: instantiate the "
        "Replica, and to create an ongoing association between Source "
        "and Replica. If 0 is returned, the function completed "
        "successfully and no ConcreteJob instance is created. "
        "If 0x1000 a ConcreteJob will be started."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job completed with no error", "Not Supported", 
            "Unknown", "Timeout", "Failed","Invalid Parameter", 
            "DMTF Reserved", "Method parameters checked - job started",
            "Method Reserved","Vendor Specific"}]
    uint32 CreateReplica(
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).")]
        CIM_ConcreteJob ref Job,
        [IN, Required, Description(
            "The Source Storage Object.") ]
        CIM_LogicalElement ref SourceElement,
        [OUT, IN(false), Description(
            "Reference to the created target storage element "
            "(replica).") ]
        CIM_LogicalElement ref TargetElement,
        [IN, Description(
            "The definition for the StorageSetting to be maintained "
            "by the target storage object (replica).") ]
        CIM_StorageSetting ref TargetSettingGoal,
        [IN, Description(
            "The underlying storage for the target element (replica), "
            "will be drawn from TargetPool if specified, otherwise "
            "allocation is implementation specific.")] 
        CIM_StoragePool ref TargetPool,
        [IN, Description(
            "CopyType describes the type of copy that will be made "
            "Values are: \n "
            "  Async: create and maintain an asynchronous "
            "copy of the source.\n "
            "  Sync: create and maintain a synchronized copy "
            "of the source. \n" 
            "  UnSyncAssoc: create an unsynchronized copy and "
            "maintain an association to the source. \n "
            "  UnSyncUnAssoc: create unassociated copy of the "
            "        source element.  "),
            ValueMap {"2", "3", "4", "5", "..", "0x8000.."},
            Values {"Async", "Sync", "UnSyncAssoc", "UnSyncUnAssoc",
                "DMTF Reserved", "Vendor Specific"} ]
        uint16 CopyType);

    [Description (
        "Starts a job to modify the synchronization association "
        "between two storage objects. If 0 is returned, the "
        "function completed successfully and no ConcreteJob "
        "instance was created. If 0x1000 a ConcreteJob will "
        "be started."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job completed with no error", "Not Supported", 
            "Unknown", "Timeout", "Failed","Invalid Parameter", 
            "DMTF Reserved", 
            "Method parameters checked - job started",
            "Method Reserved","Vendor Specific"} ]
    uint32 ModifySynchronization(
        [IN, Description(
            "Operation describes the type of modification "
            "to be made to the replica. Values are: \n "
             "  Detach: 'forget' the synchronization between "
             "two storage objects. Start to treat the objects as "
             "independent\n "
             "  Fracture: Suspend the synchronization between "
             "two storage objects. The association is remembered and "
             "typically changes are remembered to allow a fast "
             "resynchronization. This is typically used during "
             "a backup cycle to allow one of the objects to be "
             "copied while the other remains in production.\n"
             "  Resync Replica: Re-establish the synchronization of "
             "a replica. If CopyJob is Sync or Async, this will "
             "negate the action of a previous Fracture operation.\n"
             "  Restore from Replica : renew the contents of "
             "the original Storage Object from a replica."),
             ValueMap {"0","1","2", "3", "4", "5", "..", "0x8000.."},
             Values {" DMTF Reserved", "DMTF Reserved", "Detach", 
                 "Fracture", "Resync Replica", "Restore from Replica"
                 "DMTF Reserved", "Vendor Specific"} ]
        uint16 Operation,
        [OUT, IN(false), Description(
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob ref Job,
        [IN, Description(
            "The referenced to the StorageSynchronized association "
            "describing the storage source/replica relationship.") ]
        CIM_StorageSynchronized ref Synchronization);

    [Description("Returns a list of classes as an parameter that "
        "the given ManagedElement supports or has installed."), 
        ValueMap {"0", "1", "2", "4", "..", "0x8000.."},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 GetClassTypes(
        [IN, 
            ValueMap {"2", "3"}, 
            Values {"Supports", "Installed"},
            Description (
                "The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description(
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.")]
        boolean Recursive,
        [IN, Description(
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [OUT, IN (false), Description(
            "Array containing the class names (typically the leaf "
            "classes) that the given ManagedElement can support or "
            "has installed.") ]
        string ClassTypes[]);

    [Description("Returns a list of UnitTypes as an parameter that "
        "are installed for a given ClassType on a given Managed"
        "Element."),
        ValueMap {"0", "1", "2", "4", "..", "0x8000.."},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 GetUnitTypes(
        [IN, 
            ValueMap {"2", "3"}, 
            Values {"Supported", "Installed"},
            Description ("The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description(
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.")]
        boolean Recursive,
        [IN, Description(
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [IN, Description(
            "The ClassType for the query. This should be a entry "
            "returned in the GetClassTypes.ClassTypes property.") ]
        string ClassType,
        [OUT, IN (false), Description(
            "A list of supported UnitTypes."),
            ValueMap{"2","3","4","5","6","7","8","9","10", "..", 
                "0x8000.."},
            Values {"None", "Front Side", "Back Side", "Contained",
                "Connected", "I/O", "Memory", "StorageMediaLocation",
                "Megabytes", "DMTF Reserved", "Vendor Specific"},
            ModelCorrespondence {
                "CIM_ConfigurationReportingService."
                "ReportCapacity(UnitType)"} ]
        uint16 UnitTypes[] );

    [Description("Returns the maximum number supported or the "
        "number of currently installed units for the given UnitType, "
        "for a given ClassType on a given ManagedElement."),
        ValueMap {"0", "1", "2", "4", "..", "0x8000.."},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 ReportCapacity(
        [IN, 
            ValueMap {"2", "3"}, 
            Values {"Supported", "Installed"},
            Description ("The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description(
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.")]
        boolean Recursive,
        [IN, Description(
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [IN, Description(
            "The ClassType for the query. This should be a entry "
            "returned in the GetClassTypes.ClassTypes property.") ]
        string ClassType,
        [IN, Description(
            "The UnitType for the query."),
            ValueMap{"2","3","4","5","6","7","8","9","10", "..", 
                "0x8000.."},
            Values {"None", "Front Side", "Back Side", "Contained",
                "Connected", "I/O", "Memory", "StorageMediaLocation",
                "Megabytes", "DMTF Reserved", "Vendor Specific"},
            ModelCorrespondence {
                "CIM_ConfigurationReportingService."
                "GetUnitTypes(UnitTypes)"} ]
        uint16 UnitType,
        [OUT, IN (false), Description (
            "The maximum number of supported or the number of "
            "currently installed units.") ]
        uint64 NumberOfUnits);
};


// ====================================================================
// StorageSettingWithHints
// ====================================================================
[Experimental, Version("2.7.0"), Description (
    "This subclass of StorageSetting allows a client to specify "
    "'hint's for optimization of the volume performance. The effect "
    "that these hints have will be implementation dependent.") ]
class CIM_StorageSettingWithHints: CIM_StorageSetting {
    
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the importance "
        "placed on data availability. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 DataAvailabilityHint;
        
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the randomness "
        "of accesses. Values are 0=Entirely Sequential to "
        "10=Entirely Random.") ]
    uint16 AccessRandomnessHint;

    [MinValue (0), MaxValue, Description (
        "This hint is an indication from a client of the direction "
        "of accesses. Values are 0=Entirely Read to "
        "10=Entirely Write") ]
    uint16 AccessDirectionHint;

    [Description (
        "This hint is an indication from a client of the optimal "
        "access sizes.  Several sizes can be specified. "),
        Units ("MegaBytes") ]
    uint16 AccessSizeHint[];

    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client how important "
        "access latency is. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 AccessLatencyHint;

    [MinValue (0), MaxValue, Description (
        "This hint is an indication from a client of bandwidth "
        "prioritization. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 AccessBandwidthWeight;

    [MinValue (0), MaxValue (10),Description (
        "This hint is an indication of the importance the client "
        "places on the cost of storage. Values are 0=Don't Care to "
        "10=Very Important. A StorageVolume provider might choose "
        "to place data on low cost or high cost drives based on "
        "this parameter.") ]
    uint16 StorageCostHint;

    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication of the importance placed on "
        "storage efficiency by the client. Values are 0=Don't Care "
        "to 10=Very Important. A StorageVolume provider might choose "
        "different RAID levels based on this hint.") ]
    uint16 StorageEfficiencyHint;
};


// ==================================================================
// HostedStoragePool
// ==================================================================
[Association, Aggregation, Experimental, Composition, 
    Version ("2.7.0"), Description (
        "SystemStoragePool is a specialization of SystemComponent "
        "association that establishes that the StoragePool is "
        "defined in the context of the System.") ]
class CIM_HostedStoragePool : CIM_SystemComponent {
        
    [Override ("GroupComponent"), Aggregate, Max (1), Min (1), 
        Description ("The parent system in the Association.") ] 
    CIM_System REF GroupComponent;
 
    [Override ("PartComponent"), Description (
        "The StoragePool that is a component of a System.") ] 
    CIM_StoragePool REF PartComponent;
};


// ===================================================================
// AllocatedFromStoragePool
// ===================================================================
[Association, Experimental, Version ("2.7.0"), Description (
    "AllocatedFromStoragePool is an association describing how "
    "LogicalElements are allocated from underlying StoragePools. "
    "These elements typically would be subclasses of StorageExtents "
    "or StoragePools.") ] 
class CIM_AllocatedFromStoragePool : CIM_Dependency {
    
    [Override ("Antecedent"), 
        Description ("The StoragePool.")]
    CIM_StoragePool REF Antecedent;

    [Override ("Dependent"),
        Description ("The subsidiary element.")]
    CIM_LogicalElement REF Dependent;

    [Description (
        "Space Consumed from this Pool"), Units("MegaBytes")]
    uint64 SpaceConsumed;
};



// ===================================================================
// end of file
// ===================================================================
