// ===================================================================
// Title:       Core Device 2.7
// Filename:    Core27_Device.mof
// Version:     2.7.0
// Release:     Preliminary 
// Date:        06/13/02
// ===================================================================
// Copyright 2002 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.  
// DMTF is a not-for-profit association of industry members dedicated 
// to promoting enterprise and systems management and interoperability. 
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members, 
// provided that correct attribution is given. 
// As DMTF specifications may be revised from time to time, 
// the particular version and release date should always be noted.
//
// Implementation of certain elements of this standard or proposed 
// standard may be subject to third party patent rights, including 
// provisional patent rights (herein "patent rights"). DMTF makes 
// no representations to users of the standard as to the existence 
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or 
// claimants, nor for any incomplete or inaccurate identification or 
// disclosure of such rights, owners or claimants. DMTF shall have no 
// liability to any party, in any manner or circumstance, under any 
// legal theory whatsoever, for failure to recognize, disclose, or 
// identify any such third party patent rights, or for such party’s
// reliance on the standard or incorporation thereof in its product, 
// protocols or testing procedures. DMTF shall have no liability to 
// any party implementing such standard, whether such implementation 
// is foreseeable or not, nor to any patent owner or claimant, and shall 
// have no liability or responsibility for costs or losses incurred if 
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the 
// standard from any and all claims of infringement by a patent owner 
// for such implementations.
//
// For information about patents held by third-parties which have 
// notified the DMTF that, in their opinion, such patent may relate to 
// or impact implementations of DMTF standards, visit 
// http://www.dmtf.org/about/policies/disclosures.php.
// ===================================================================
// Description: The Core Model defines basic management concepts. 
//              This Core file defines the concepts for LogicalDevices.
//
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined 
//              by other working groups, are omitted.
// ==================================================================
// Prerequisite:  Core27_Qualifiers
//                Core27_CoreElements (LE)
// ==================================================================
// Change Log for v2.7
// CR624 - Fixed several of the DMI mapping strings that were missing 
//         the attribute number in LogicalDevice.
// CR720 - Deprecate the use of LogicalDevice.PowerManagementSupported,
//         LogicalDevice.PowerManagementCapabilities, & LogicalDevice.
//         SetPowerState().
// CR722 - Add StorageExtent.ExtentStatus
// CR761 - Add the Composition Qualifer to SystemDevice
// CR763 - Change subclassing of LogicalDevice from LogicalElement to
//         EnabledLogicalElement
//       - Deprecate LogicalDevice.StatusInfo
//       - Update description of LogicalDevice.EnableDevice() to 
//         explain position relative to LogicalDevice.RequestedStatus
//       - Update description of LogicalDevice.OnlineDevice() and 
//         QuiesceDevice to make reference to EnabledStatus.
// CR775 - StorageExtent.NoSinglePointOfFailure, StorageExtent. 
//         DataRedundancy, StorageExtent.SpindleRedundancy
// CR777 - Add StorageExtent.DeltaReservation
// ==================================================================

#pragma locale ("en_US")

// ===================================================================
// LogicalDevice
// ===================================================================
[Abstract, Version ("2.7.0"), Description (
    "An abstraction or emulation of a hardware entity, that may "
    "or may not be Realized in physical hardware. Any "
    "characteristics of a LogicalDevice that are used to manage "
    "its operation or configuration are contained in, or "
    "associated with, the LogicalDevice object. Examples of the "
    "operational properties of a Printer would be paper sizes "
    "supported, or detected errors. Examples of the configuration "
    "properties of a Sensor Device would be threshold settings. "
    "Various configurations could exist for a LogicalDevice. "
    "These configurations could be contained in Setting objects "
    "and associated with the LogicalDevice.") ] 
class CIM_LogicalDevice : CIM_EnabledLogicalElement {

    [Propagated("CIM_System.CreationClassName"), 
        Key, MaxLen (256), Description (
            "The scoping System's CreationClassName.") ]
    string SystemCreationClassName;
    
    [Propagated("CIM_System.Name"),
        Key, MaxLen (256), Description (
            "The scoping System's Name.") ]
    string SystemName;
    
    [Key, MaxLen (256), Description (
        "CreationClassName indicates the name of the class or "
        "the subclass used in the creation of an instance. When "
        "used with the other key properties of this class, this "
        "property allows all instances of this class and its "
        "subclasses to be uniquely identified.") ]
    string CreationClassName;
    
    [Key, MaxLen (64), Description (
        "An address or other identifying information to uniquely "
        "name the LogicalDevice.") ]
    string DeviceID;
    
    [Deprecated {"CIM_PowerManagementCapabilities"}, Description (
        "Boolean indicating that the Device can be power managed. "
        "The use of this property has been deprecated.  Instead, "
        "the existence of an associated PowerManagementCapabilities "
        "class (associated using the ElementCapabilities relationhip) "
        "indicates that power management is supported.") ]
    boolean PowerManagementSupported;
    
    [Deprecated {"CIM_PowerManagementCapabilities.PowerCapabilities"},
        Description(
            "An enumerated array describing the power management "
            "capabilities of the Device. The use of this property "
            "has been deprecated.  Instead, the PowerCapabilites "
            "property in an associated PowerManagementCapabilities "
            "class should be used." ),
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "7"},
        Values {"Unknown", "Not Supported", "Disabled", 
            "Enabled", "Power Saving Modes Entered Automatically",
            "Power State Settable", "Power Cycling Supported",
            "Timed Power On Supported"} ]
    uint16 PowerManagementCapabilities[];
    
    [Description (
        "The primary availability and status of the Device. (Additional "
        "status information can be specified using the Additional"
        "Availability array property.) For example, the Availability "
        "property indicates that the Device is running and has full "
        "power (value=3), or is in a warning (4), test (5), degraded "
        "(10) or power save state (values 13-15 and 17). Regarding the "
        "Power Save states, these are defined as follows: "
        "Value 13 (\"Power Save - Unknown\") indicates "
        "that the Device is known to be in a power save mode, but its "
        "exact status in this mode is unknown; 14 (\"Power Save - Low "
        "Power Mode\") indicates that the Device is in a power save "
        "state but still functioning, and may exhibit degraded "
        "performance; 15 (\"Power Save - Standby\") describes that "
        "the Device is not functioning but could be brought to full "
        "power 'quickly'; and value 17 (\"Power Save - Warning\") "
        "indicates that the Device is in a warning state, though also "
        "in a power save mode."), 
        ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9",
            "10", "11", "12", "13", "14", "15", "16", "17", "18", 
            "19", "20", "21"},
        Values {"Other", "Unknown", "Running/Full Power", "Warning", 
            "In Test", "Not Applicable", "Power Off", "Off Line", 
            "Off Duty", "Degraded", "Not Installed", "Install Error",
            "Power Save - Unknown", "Power Save - Low Power Mode", 
            "Power Save - Standby", "Power Cycle","Power Save - Warning", 
            "Paused", "Not Ready", "Not Configured", "Quiesced"}, 
        MappingStrings {"MIF.DMTF|Operational State|006.5",
            "MIB.IETF|HOST-RESOURCES-MIB.hrDeviceStatus", 
            "MIF.DMTF|Host Device|001.5"},
        ModelCorrespondence {
            "CIM_LogicalDevice.AdditionalAvailability"} ]
    uint16 Availability;
    
    [Deprecated {"CIM_EnabledLogicalElement.EnabledStatus"}, 
        Description (
        "  The StatusInfo property indicates whether the Logical"
        "Device is in an enabled (value = 3), disabled (value = "
        "4) or some other (1) or unknown (2) state. If this "
        "property does not apply to the LogicalDevice, the value, "
        "5 (\"Not Applicable\"), should be used.  StatusInfo has "
        "been deprecated in lieu of a more clearly named property "
        "with additional enumerated values (EnabledStatus), "
        "that is inherited from ManagedSystemElement. \n"
        "  If a Device is (\"Enabled\")(value=3), it has been "
        "powered up, and is configured and operational.  The Device "
        "may or may not be functionally active, depending on whether "
        "its Availability (or AdditionalAvailability) indicate that "
        "it is (\"Running/Full Power\")(value=3) or (\"Off line\")"
        "(value=8). In an enabled but offline mode, a Device may be "
        "performing out-of-band requests, such as running Diagnostics. "
        "If (\"Disabled\") StatusInfo value=4), a Device can only be " 
        "\"enabled\" or powered off.  In a personal computer "
        "environment, (\"Disabled\") means that the Device's driver "
        "is not available in the stack. In other environments, a "
        "Device can be disabled by removing its configuration file. A "
        "disabled device is physically present in a System and "
        "consuming resources, but can not be communicated with until "
        "a load of a driver, a load of a configuration file or some "
        "other \"enabling\" activity has occurred."),
        ValueMap {"1", "2", "3", "4", "5"},
        Values {"Other", "Unknown", "Enabled",
            "Disabled", "Not Applicable"},
       MappingStrings {"MIF.DMTF|Operational State|006.4"} ]
    uint16 StatusInfo;
    
    [Description (
        "LastErrorCode captures the last error code reported by " 
        "the LogicalDevice.") ]
    uint32 LastErrorCode;
    
    [Description (
        "ErrorDescription is a free-form string supplying more " 
        "information about the error recorded in LastErrorCode, and " 
        "information on any corrective actions that may be taken.") ]
    string ErrorDescription;
    
    [Description (
        "ErrorCleared is a boolean property indicating that the " 
        "error reported in LastErrorCode is now cleared.") ]
    boolean ErrorCleared;
    
    [MaxLen (256), ArrayType ("Indexed"), Description (
        "OtherIdentifyingInfo captures additional data, beyond "
        "DeviceID information, that could be used to identify a "
        "LogicalDevice. One example would be to hold the Operating"
        "System's user friendly name for the Device in this "
        "property."),
        ModelCorrespondence {
            "CIM_LogicalDevice.IdentifyingDescriptions"} ]
    string OtherIdentifyingInfo[];
    
    [Description (
        "The number of consecutive hours that this Device has been "
        "powered, since its last power cycle."),
        Units ("Hours"), Counter ]
    uint64 PowerOnHours;
    
    [Description (
        "The total number of hours that this Device has been "
        "powered."),
        Units ("Hours"), Counter ]
    uint64 TotalPowerOnHours;
    
    [ArrayType ("Indexed"), Description (
        "An array of free-form strings providing explanations "
        "and details behind the entries in the OtherIdentifyingInfo "
        "array. Note, each entry of this array is related to the "
        "entry in OtherIdentifyingInfo that is located at the same "
        "index."),
        ModelCorrespondence {"CIM_LogicalDevice.OtherIdentifyingInfo"} ]
    string IdentifyingDescriptions[];
    
    [Description (
        "Additional availability and status of the Device, beyond that "
        "specified in the Availability property. The Availability "
        "property denotes the primary status and availability of the "
        "Device. In some cases, this will not be sufficient to denote "
        "the complete status of the Device. In those cases, the "
        "AdditionalAvailability property can be used to provide further "
        "information. For example, a Device's primary Availability may "
        "be \"Off line\" (value=8), but it may also be in a low power "
        "state (AdditonalAvailability value=14), or the Device could be "
        "running Diagnostics (AdditionalAvailability value=5, \"In "
        "Test\")."),
        ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9",
            "10", "11", "12", "13", "14", "15", "16", "17", "18",  
            "19", "20", "21"},
        Values {"Other", "Unknown", "Running/Full Power", "Warning", 
            "In Test", "Not Applicable", "Power Off", "Off Line", 
            "Off Duty", "Degraded", "Not Installed", "Install Error",
            "Power Save - Unknown", "Power Save - Low Power Mode", 
            "Power Save - Standby", "Power Cycle", 
            "Power Save - Warning", "Paused", "Not Ready",
            "Not Configured", "Quiesced"}, 
        ModelCorrespondence {"CIM_LogicalDevice.Availability"} ]
    uint16 AdditionalAvailability[];
    
    [Description (
        "Maximum time in milliseconds, that a Device can run in "
        "a \"Quiesced\" state. A Device's state is defined in its "
        "Availability and AdditionalAvailability properties, where "
        "\"Quiesced\" is conveyed by the value 21. What occurs at "
        "the end of the time limit is device-specific. The Device "
        "may unquiesce, may offline or take other action. A value of "
        "0 indicates that a Device can remain quiesced indefinitely."), 
        Units ("MilliSeconds") ]
    uint64 MaxQuiesceTime;
    
    [Deprecated {"CIM_PowerManagementService.SetPowerState"},
        Description(
            "Sets the power state of the Device. "
            "The use of this method has been deprecated.  Instead, "
            "use the SetPowerState method in the associated "
            "PowerManagementService class." ) ]
    uint32 SetPowerState(
        [IN, ValueMap {"1", "2", "3", "4", "5", "6"},
            Values {"Full Power", "Power Save - Low Power Mode", 
                "Power Save - Standby", "Power Save - Other", 
                "Power Cycle", "Power Off"} ] 
        uint16 PowerState, 
        [IN] datetime Time);
    
    [Description (
        "Requests a reset of the LogicalDevice. The return value "
        "should be 0 if the request was successfully executed, "
        "1 if the request is not supported and some other value "
        "if an error occurred. In a subclass, the set of possible "
        "return codes could be specified, using a ValueMap qualifier "
        "on the method. The strings to which the ValueMap contents "
        "are 'translated' may also be specified in the subclass as a "
        "Values array qualifier.") ]
    uint32 Reset();
     
    [Description (
        "  Requests that the LogicalDevice be enabled (\"Enabled\" "
        "input parameter = TRUE) or disabled (= FALSE). If "
        "successful, the Device's StatusInfo/EnabledStatus properties "
        "should reflect the desired state (enabled/disabled). "
        "Note that this method's function overlaps with the "
        "RequestedStatus property. RequestedStatus was added to "
        "the model to maintain a record (i.e., a persisted value) "
        "of the last status request. Invoking the EnableDevice "
        "method should set the RequestedStatus property "
        "appropriately. \n"
        "  The return code should be 0 if the request was "
        "successfully executed, 1 if the request is not supported "
        "and some other value if an error occurred. In a subclass, "
        "the set of possible return codes could be specified, "
        "using a ValueMap qualifier on the method. The strings to "
        "which the ValueMap contents are 'translated' may also be "
        "specified in the subclass as a Values array qualifier.") ]
    uint32 EnableDevice(
        [IN] boolean Enabled);
    
    [Description (
        "Requests that the LogicalDevice be brought online (\"Online\""
        " input parameter = TRUE) or taken offline (= FALSE). "
        "\"Online\" indicates that the Device is ready to accept "
        "requests, and is operational and fully functioning. In this "
        "case, the Device's Availability property would be set to "
        "a value of 3 (\"Running/Full Power\"). \"Offline\" indicates "
        "that a Device is powered up and operational, but not "
        "processing functional requests. In an offline state, a Device"
        " may be capable of running diagnostics or generating "
        "operational alerts. For example, when the \"Offline\" button "
        "is pushed on a Printer, the Device is no longer available to "
        "process print jobs, but could be available for diagnostics "
        "or maintenance. \n"
        "If this method is successful, the Device's Availability and "
        "AdditionalAvailability properties should reflect the updated "
        "status. If a failure occurs trying to bring the Device online "
        "or offline, it should remain in its current state. IE, the "
        "request, if unsuccessful, should not leave the Device in an "
        "indeterminate state. When bringing a Device back \"Online\", "
        "from an \"Offline\" mode, the Device should be restored to "
        "its last \"Online\" state, if at all possible. Only a Device "
        "that has an EnabledStatus/StatusInfo of \"Enabled\" and has "
        "been configured can be brought online or taken offline. \n"
        "OnlineDevice should return 0 if successful, 1 if the request "
        "is not supported at all, 2 if the request is not supported "
        "due to the current state of the Device, and some other value "
        "if any other error occurred. In a subclass, the set of "
        "possible return codes could be specified, using a ValueMap "
        "qualifier on the method. The strings to which the ValueMap "
        "contents are 'translated' may also be specified in the "
        "subclass as a Values array qualifier.") ]
    uint32 OnlineDevice(
        [IN] boolean Online);
    
    [Description (
        "Requests that the LogicalDevice cleanly cease all current "
        "activity (\"Quiesce\" input parameter = TRUE) or resume "
        "activity (= FALSE). For this method to quiesce a Device, "
        "that Device should have an Availability (or Additional"
        "Availability) of \"Running/Full Power\" (value=3) and an "
        "EnabledStatus/StatusInfo of \"Enabled\". For example, if "
        "quiesced, a Device may then be offlined for diagnostics, "
        "or disabled for power off and hot swap.  For the method to "
        "\"unquiesce\" a Device, that Device should have an "
        "Availability (or AdditionalAvailability) of \"Quiesced\" "
        "(value=21) and an EnabledStatus/StatusInfo of \"Enabled\". "
        "In this case, the Device would be returned to an \"Enabled\" "
        "and \"Running/Full Power\" status. \n"
        "The method's return code should indicate the success or "
        "failure of the quiesce. It should return 0 if successful, "
        "1 if the request is not supported at all, 2 if the request "
        "is not supported due to the current state of the Device, "
        "and some other value if any other error occurred. In a "
        "subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method.  The "
        "strings to which the ValueMap contents are 'translated' may "
        "also be specified in the subclass as a Values array "
        "qualifier.") ]
    uint32 QuiesceDevice(
        [IN] boolean Quiesce);
    
    [Description (
        "Requests that the Device capture its current configuration, "
        "setup and/or state information in a backing store. The goal "
        "would be to use this information at a later time (via the "
        "RestoreProperties method), to return a Device to its present "
        "\"condition\". This method may not be supported by all Devices. "
        "The method should return 0 if successful, 1 if the request is "
        "not supported, and some other value if any other error occurred. "
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The strings "
        "to which the ValueMap contents are 'translated' may also be "
        "specified in the subclass as a Values array qualifier.") ]
    uint32 SaveProperties();
    
    [Description (
        "Requests that the Device re-establish its configuration, "
        "setup and/or state information from a backing store. The "
        "intent is to capture this information at an earlier time "
        "(via the SaveProperties method), and use it to return a "
        "Device to this earlier \"condition\". This method may not "
        "be supported by all Devices. The method should return 0 if "
        "successful, 1 if the request is not supported, and some "
        "other value if any other error occurred. In a subclass, "
        "the set of possible return codes could be specified, using "
        "a ValueMap qualifier on the method. The strings to which "
        "the ValueMap contents are 'translated' may also be specified "
        "in the subclass as a Values array qualifier.") ]
    uint32 RestoreProperties();        
};  

   
// ==================================================================
// Realizes
// ==================================================================
[Association, Version ("2.6.0"), Description (
    "CIM_Realizes is the association that defines the mapping "
    "between LogicalDevices and the PhysicalElements that "
    "implement them.") ] 
class CIM_Realizes : CIM_Dependency {
    
    [Override ("Antecedent"), Description (
        "The physical component that implements the Device.") ]
    CIM_PhysicalElement REF Antecedent;
    
    [Override ("Dependent"), Description (
        "The LogicalDevice.") ]
    CIM_LogicalDevice REF Dependent;
};

     
// ==================================================================
// SystemDevice
// ==================================================================
[Association, Aggregation, Composition, Version ("2.7.0"), 
    Description (
        "LogicalDevices may be aggregated by a System.  This " 
        "relationship is made explicit by the SystemDevice "
        "association.") ]
class CIM_SystemDevice:CIM_SystemComponent {

    [Override ("GroupComponent"), Aggregate, Max (1), Min (1), 
        Description ("The parent system in the Association.") ] 
    CIM_System REF GroupComponent;
    
    [Override ("PartComponent"), Weak, Description (
        "The LogicalDevice that is a component of a System.") ] 
    CIM_LogicalDevice REF PartComponent;
};


// ===================================================================
// DeviceServiceImplementation
// ===================================================================
[Association, Version ("2.6.0"), Description (
    "An association between a Service and how it is implemented. "
    "The cardinality of this association is many-to-many. "
    "A Service may be provided by more than one Logical"
    "Device, operating in conjunction.  And, any Device may "
    "provide more than one Service.  When multiple Devices are "
    "associated with a single Service, it is assumed that these "
    "elements operate in conjunction to provide the Service.  If "
    "different implementations of a Service exist, each of these "
    "implementations would result in individual instantiations "
    "of the Service object.  These individual instantiations "
    "would then have associations to the unique implementations.") ]
class CIM_DeviceServiceImplementation : CIM_Dependency {

    [Override ("Antecedent"),
        Description ("The LogicalDevice.") ]
    CIM_LogicalDevice REF Antecedent;
   
    [Override ("Dependent"),
        Description ("The Service implemented using the Logical"
        "Device.") ]
    CIM_Service REF Dependent;
};


// ===================================================================
// DeviceSAPImplementation
// ===================================================================
[Association, Version ("2.6.0"), Description (
    "An association between a ServiceAccessPoint and how "
    "it is implemented. The cardinality of this association "
    "is many-to-many.  A SAP may be provided by more "
    "than one LogicalDevice, operating in conjunction.  And, any "
    "Device may provide more than one ServiceAccessPoint. "
    "When many LogicalDevices are associated with a single "
    "SAP, it is assumed that these elements operate in "
    "conjunction to provide the AccessPoint.  If different "
    "implementations of a SAP exist, each of these implementations "
    "would result in individual instantiations of the "
    "ServiceAccessPoint object.  These individual instantiations "
    "would then have associations to the unique implementations.") ]
class CIM_DeviceSAPImplementation : CIM_Dependency {
    
    [Override ("Antecedent"),
        Description ("The LogicalDevice.") ]
    CIM_LogicalDevice REF Antecedent;
    
    [Override ("Dependent"),
        Description (
        "The ServiceAccessPoint implemented using the "
        "LogicalDevice.") ]
    CIM_ServiceAccessPoint REF Dependent;
};


// ===================================================================
// StorageExtent
// ===================================================================
[Version ("2.7.0"), Description (
    "StorageExtent describes the capabilities and management of "
    "the various media that exist to store data and allow data "
    "retrieval. This superclass could be used to represent the "
    "various components of RAID (Hardware or Software) or as a "
    "raw logical extent on top of physical media.") ] 
class CIM_StorageExtent : CIM_LogicalDevice {

    [Description ("Type of data organization used."), 
        ValueMap {"0", "1", "2", "3", "4"},
        Values {"Other", "Unknown", "Fixed Block", "Variable Block", 
            "Count Key Data"} ]
    uint16 DataOrganization;

    [Description (
        "A free form string describing the media and/or its use."),
        MappingStrings {
            "MIB.IETF|HOST-RESOURCES-MIB.hrStorageDescr"} ]
    string Purpose;

    [Description (
        "Access describes whether the media is readable (value=1), "
        "writeable (value=2), or both (value=3). \"Unknown\" (0) "
        "and \"Write Once\" (4) can also be defined."),
        ValueMap {"0", "1", "2", "3", "4"},
        Values {"Unknown", "Readable", "Writeable", 
            "Read/Write Supported", "Write Once"} ]
    uint16 Access;

    [Description (
        "ErrorMethodology is a free-form string describing "
        "the type of error detection and correction supported "
        "by this StorageExtent.") ]
    string ErrorMethodology;

    [Description (
        "Size in bytes of the blocks which form this StorageExtent. "
        "If variable block size, then the maximum block size in bytes "
        "should be specified. If the block size is unknown or if a "
        "block concept is not valid (for example, for AggregateExtents, "
        "Memory or LogicalDisks), enter a 1."), 
        Units ("Bytes"),
        MappingStrings {"MIF.DMTF|Host Storage|001.4", 
            "MIB.IETF|HOST-RESOURCES-MIB.hrStorageAllocationUnits,"
            "MIF.DMTF|Storage Devices|001.5"} ]
    uint64 BlockSize;

    [Description (
        "Total number of logically contiguous blocks, of size Block"
        "Size, which form this Extent. The total size of the Extent "
        "can be calculated by multiplying BlockSize by NumberOfBlocks. "
        "If the BlockSize is 1, this property is the total size of the "
        "Extent."),
        MappingStrings {"MIF.DMTF|Host Storage|001.5", 
            "MIB.IETF|HOST-RESOURCES-MIB.hrStorageSize"} ]
     uint64 NumberOfBlocks;

     [Description ( 
         "The maximum number of blocks, of size BlockSize, which are "
         "available for consumption when layering StorageExtents "
         "using the BasedOn association. This property only has meaning "
         "when this StorageExtent is an Antecedent reference in a "
         "BasedOn relationship. For example, a StorageExtent could be "
         "composed of 120 blocks. However, the Extent itself may use 20 "
         "blocks for redundancy data. If another StorageExtent is "
         "BasedOn this Extent, only 100 blocks would be available to it. "
         "This information ('100 blocks is available for consumption') "
         "is indicated in the ConsumableBlocks property.") ]
     uint64 ConsumableBlocks;

     [Description (
         "True indicates that the underlying StorageExtent(s) "
         "participate in a StorageRedundancyGroup.") ]
     boolean IsBasedOnUnderlyingRedundancy;

    [Description (
        "Boolean set to TRUE if the Storage is sequentially accessed "
        "by a MediaAccessDevice. A TapePartition is an example of a "
        "sequentially accessed StorageExtent. StorageVolumes, Disk"
        "Partitions and LogicalDisks represent randomly accessed "
        "Extents.") ]
    boolean SequentialAccess;
        
    [Experimental, Description (
        "StorageExtents have additional status information beyond that "
        "captured in the Availability and StatusInfo properties, inherited "
        "from ManagedSystemElement. This additional information (for "
        "example, \"Protection Disabled\", value=9) is captured in the "
        "VolumeStatus property."),
        ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
            "10", "11", "12", "13", "14"},
        Values {"Other", "Unknown", "None/Not Applicable", "Broken", 
            "Data Lost", "Dynamic Reconfig", "Exposed", 
            "Fractionally Exposed", "Partially Exposed", 
            "Protection Disabled", "Readying", "Rebuild", 
            "Recalculate", "Spare in Use", "Verify In Progress"} ]
    uint16 ExtentStatus;
    
    [Experimental, Description (
        "Indicates whether or not there exists no single point of failure.")]
    boolean NoSinglePointOfFailure;

    [Experimental, Description (
        "Number of complete copies of data maintained.")]
    uint16 DataRedundancy;

    [Experimental, Description (
        "How many disk spindles can fail without data loss.")]
    uint16 SpindleRedundancy;

    [Experimental, MinValue (1), MaxValue (100), Description (
        "Current value for Delta reservation. ") ]
    uint16 DeltaReservation;
};


// ===================================================================
// BasedOn
// ===================================================================
[Association, Version ("2.6.0"), Description (
   "BasedOn is an association describing how StorageExtents can "
   "be assembled from lower level Extents. For example, "
   "ProtectedSpaceExtents are parts of PhysicalExtents, while "
   "VolumeSets are assembled from one or more Physical or "
   "ProtectedSpaceExtents. As another example, CacheMemory "
   "can be defined independently and realized in a PhysicalElement "
   "or can be 'based on' Volatile or NonVolatileStorageExtents.") ] 
class CIM_BasedOn : CIM_Dependency {

   [Override ("Antecedent"), Description (
       "The lower level StorageExtent.") ]
   CIM_StorageExtent REF Antecedent;

   [Override ("Dependent"), Description (
       "The higher level StorageExtent.") ]
   CIM_StorageExtent REF Dependent;

   [Description (
       "StartingAddress indicates where in lower level storage, "
       "the higher level Extent begins.") ] 
   uint64 StartingAddress;

   [Description (
       "EndingAddress indicates where in lower level storage, "
       "the higher level Extent ends. This property is useful when "
       "mapping non-contiguous Extents into a higher level grouping.") ] 
   uint64 EndingAddress;

   [Description (
       "If there is an order to the BasedOn associations that "
       "describe how a higher level StorageExtent is assembled, the "
       "OrderIndex property indicates this. When an order exists, "
       "the instances of BasedOn with the same Dependent value "
       "(i.e., the same higher level Extent) should place unique "
       "values in the OrderIndex property. The lowest value implies "
       "the first member of the collection of lower level Extents, "
       "and increasing values imply successive members of the "
       "collection. If there is no ordered relationship, a value "
       "of zero should be specified. An example of the use of this "
       "property is to define a RAID-0 striped array of 3 disks. "
       "The resultant RAID array is a StorageExtent that is "
       "dependent on (BasedOn) the StorageExtents that describe "
       "each of the 3 disks. The OrderIndex of each BasedOn "
       "association from the disk Extents to the RAID array could "
       "be specified as 1, 2 and 3 to indicate the order in which "
       "the disk Extents are used to access the RAID data.") ]
   uint16 OrderIndex;
};


// ===================================================================
// end of file
// ===================================================================
