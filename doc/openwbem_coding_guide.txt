-----------------------------------------------------------------------------
Don't use bool (or OpenWBEM::Bool) in parameter lists.  It makes calling code 
impossible to understand.  Use an enum instead.
	e.g.:  f(true, false, true, true); // what the hell is this doing?
		// I'll have to look up the function declaration to find out!
	       f(DO_X, OMIT_Y, USE_Z, DO_A); // don't even need a comment here.
Using bools makes it difficult (sometimes impossible) to overload the
function, and can also make it hard to catch errors such as swapping the order
of parameters and such.
-----------------------------------------------------------------------------
Naming conventions:
enums begin with E, and if they're used as 
a parameter to a function, they should end with Flag.  enum values should be
all caps, with underscores between words, and begin with E_.  Avoid anonymous
(aka unnamed) enums.  Don't use an int variable to store an enum value. i.e.:

// this is bad
enum
{
	E_A,
	E_B
};

int myEnumVal = E_A;

// do this instead
enum EMyEnum
{
	E_A,
	E_B
};

EMyEnum myEnumVal = E_A;

Don't assign numerical values to enum items unless they have some external
meaning.  Having numerical values makes enums prone to error as well as makes
them hard to maintain or refactor.  It sucks to have to renumber all the
values just to insert a new item in the middle.

All classes and public identifiers (anything in a header) must be in namespace
OpenWBEM.  If it's not meant for external use, such as internal implementation 
details or variables local to a translation unit, then it should be put into 
an unnamed namespace to avoid possible duplicate symbol link-time errors.  
This can be a worse issue than you might think because of providers, all the 
symbols are global and can possibly conflict with symbols from other providers 
or the cimom.  All file names begin with OW_, and try never to create 2
files with the same name, because of the way gcc implements unnamed namespaces,
basically the namespace isn't really unnamed, it's named the same as the file,
so two files with the same names can have conflicts in the unnamed namespace.
Also, development headers all end up being installed into the same directory,
so 2 files cannot have the same name.
-----------------------------------------------------------------------------
Exceptions.
When to use catch(...).  e.g.:
try
{
	//...
}
catch (...)
{
	// swallow all exceptions
}

Only do that in destructors.  Never let an exception escape a destructor, if
it does, it will probably abort the cimom.
There may be other occasions where this is appropriate, such as in threads
that need to keep running even though one iteration of it's work has failed.
In this case, the ThreadCancelledException should *never* be caught:

try
{
	//...
}
catch (ThreadCancelledException&)
{
	throw;
}
catch (...)
{
	// swallow all exceptions
}

In some cases (this should be very rare if the code is written correctly using
the RAII idiom), if may be necessary to use catch(...) like this:

try
{
	//...
}
catch (...)
{
	// do some cleanup
	throw;
}

Also, main() should catch(...) and gracefully exit.

Never use exception specifications (except for no throw "throw()", and then
only if you are 100% sure it can't throw), because it can easily lead to
abort() being called if an exception is thrown that doesn't match the
specification.  Unfortunately gcc doesn't check, and so this can easily lead
to problems.

Derive all new exceptions from OpenWBEM::Exception.  In most cases, you can simply
use the OW_DECLARE_EXCEPTION and OW_DEFINE_EXCEPTION macros.

Use the OW_THROW macro to throw an exception, this will automatically pass in
the filename and line number, which is a great debugging help.

Anytime you need to report a specific WBEM error (from CIM Operations over
HTTP), throw an OpenWBEM::CIMException.  Use the OW_THROWCIM and OW_THROWCIMMSG
macros to do this.
-----------------------------------------------------------------------------
The following CIM elements are case-insensitive: Classes, Instances, Methods,
Properties, Qualifiers and Method Parameters.
Namespaces in OpenWBEM are *NOT* case-insensitive.  i.e. root/CIMV2 is a
different namespace than root/cimv2.
-----------------------------------------------------------------------------
c++ namespaces.
NEVER put "using namespace <x>;" in a header file.  Avoid putting it in a cpp
file, especially at global scope.  Preferred practice is to either explicitly
use the namespace: "std::cout << std::endl" or to name each item:
using std::cout;
using std::endl;
A few exceptions to the rule are OpenWBEM namespaces such as WBEMFlags.

Use unnamed namespaces instead of static function/data.  Try to put new code
into a namespace, this is especially important for pluggable shared libaries
like providers.
Don't use a class with all static functions/data, instead use a namespace.

Put all library & cimom code into namespace OpenWBEM.
-----------------------------------------------------------------------------
If at all possible avoid static objects that have a constructor.  These can
lead to the dreaded "static initialization dependency order" problem.  You're
almost bound to run into it if you have a static mutex and you try and lock it
in a static object's constructor in another translation unit, or even possibly
in the same translation unit, if the mutex is declared after the other static
object.
-----------------------------------------------------------------------------
memory & low-level C-stlye code:
The #1 rule in OpenWBEM is that you can't segfault or leak memory!  This is
typically associated with low-level C-style code, so #2 rule is that you can't
write code like that unless you have a really good reason (no, optimization
isn't a good enough reason, unless you've profiled it and it's using up >30%
of the execution time)
You should always use a class with a destructor (such as Reference<>) to 
manage memory.  If you ever have to write "delete foo", then you're doing
something wrong.
Use String instead of char* and Array<> instead of raw C arrays.
Use typed input/output by using Format and stream insertion operators.  Don't
use printf/scanf and friends.
Use std::copy instead of memcpy.
Use std::fill (or fill_n) instead of memset.
Use std::sort instead of qsort()
See "Four First Steps to Modern C++ Programming" by Andrew Koenig and Barbara
E. Moo in C/C++ User's Journal Aug. 2003 pp. 49-54 if you have any more
questions or objections.
-----------------------------------------------------------------------------
All files must have a copyright notice.
-----------------------------------------------------------------------------
Header files must have a standard include guard, and it should be like this:
#ifndef OW_FILE_NAME_HPP_INCLUDE_GUARD_
#define OW_FILE_NAME_HPP_INCLUDE_GUARD_
//...
#endif
Use all caps and put underscores between words in the filename (where it would
be a new capital letter in the class name)  It's important to not get a
collision with the same include guard of another file, that will cause
unexplainable errors that lead to a lot of head-scratching and wasted time.
-----------------------------------------------------------------------------
All files must include "OW_config.h" as the first include file.
cpp files must include it's corresponding header file as the 2nd include file.
-----------------------------------------------------------------------------
Try to minimize header dependencies as much as possible.  Include the minimum
possible in header files.  You'll need to include headers for base classes as
well as any types used as member variables.  Everything else can be forward
declared.  If you use the pimpl idiom, you can get away with only including
Reference (or COWReference).  This helps to greatly reduce compilation
time and also helps prevent bloat from inline functions.
-----------------------------------------------------------------------------
If a function has unused parameters, don't comment out or omit the parameter
name to avoid an unused parameter warning.  Cast it to void at the beginning
of the function.  This makes it possible to search for specific parameters.
It also avoids problems with nested C-style comments.
-----------------------------------------------------------------------------
Make simple things simple and complex things possible
-----------------------------------------------------------------------------
If a class has more than 7 data members or 7 member functions, then it's too
big, and you should think really hard about why and try to refactor it.
Remember separation of concerns.  Each class should do 1 thing.  Each function
should do 1 thing.
Define a class's invariant.  Only functions that maintain or check the
invariant belong in a class.  Other functions belong outside the class as
utility/helper functions.
-----------------------------------------------------------------------------
Don't use spaces to indent the code.  This is so you can set your tab
spacing to your own liking in your editor.  If it's all spaces, you're stuck
with whatever the original author did.  Definitely don't mix tabs/spaces.
Here's a little bash script that will convert all spaces into tabs, in order
to maintain consistency.
for x in `find . -name '*.?pp'`; do echo $x; unexpand -4 $x > tmp; mv tmp $x;
done
-----------------------------------------------------------------------------
